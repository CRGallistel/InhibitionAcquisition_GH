function [GperU,GperT] = InfoGainRev(A,alpha)
% A is 3-col array from 'MergedUSandCS' field. Event times in Col 1; CSoff
% (-1) and on (+1) in 2nd col; US flags in 3rd. The alpha input is required
% in the Bayesian estimation of the rates, in which alpha prior
% pseudo-observations are added to the actual numberof observations in
% estimating the rates. This prior prevents any of the rate estimates from
% being 0. Zero rate estimates produced undefined or infinite divergences,
% so cannot be tolerated in the exact computation of the information gain.
% This code underwent multiple revisions over more than 6 months in a
% search for an information-theoretic computation that would explain both
% the results from these inhibitory experiments and the earlier results
% from excitatory experiments (going back to Gibbon & Balsam 1980) and the
% poor positive experiments (Balsam, Fairhurst & Gallistel, 2006). The
% version as of June 8, 2017 give three different information-theoretic
% computations.
%
%      THE FIRST VERSION is inspired by the excitatory results.
% These show that trials to acquisition is determined by the ratio of the
% rate of US occurrence during CSs to the raw rate (the rate of US
% occurrences in the experimental chamber, regardless of whether the CS is
% or is not present). It does not matter whether this ratio is varied by
% varying the C/T ratio or by varying the # of USs during the ITI (poor
% positive conditions). This result is explained if we 1) assume that the
% Dkl used in computing the information "gain" is simply the ratio of the
% CS rate to the raw rate. This ratio is a good approximation to the
% divergence OF the CS rate FROM the raw rate. The more natural calculation
% would be for the divergence OF the raw rate FROM the CS rate (that is the
% oppositely directed divergence) because that direction treats the CS rate
% as the true rate and the raw rate as the (bad) approximation to that true
% rate. It gives the cost of encoding the CS rate using the raw rate;
% whereas in the opposite direction, one gets the cost of encoding the raw
% rate using the CS rate. Thus, the direction of the divergence that has to
% be used in order to obtain an explanation of the excitatory results is a
% puzzle. Nonetheless, in this first calculation, I apply the same
% assumption to the inhibitory case. THAT IS,I calculate the divergence OF
% the ITI rate (the higher rate) FROM the raw rate.
%
%     THE SECOND VERSION approximates the divergence with the natural log
% of the ratio OF the higher rate FROM the lower rate. The reasoning
% behind this lies in an examination of the exact Dkl calculation for the
% general case (both excitatory and inhibitory conditioning)
%    Hraw = Ncs*Dkl(lamCS||lamRaw) + Niti*Dkl(lamITI||lamRaw)
% Hraw is the cost incurred per interval recorded in using the exp(lamRaw)
% distribution to generate a code for the US-US intervals experienced
% during CSs and for the US-US intervals experienced during ITIs instead of
% using the optimal code, which is generated by a model that assigns
% different rates to the CS and the background. In such a model, the rate
% assigned to the background is the ITI rate actually experienced and the
% rate assigned to the CS is the CS rate actually experienced minus the
% rate ascribed to the background (because the background is present
% whenever the CS is). The Dkl formula is:
%      Dkl(lam0||lam1) = log(lam0/lam1) + lam(lam1/lam0) - 1;
% When there are no USs during the ITIs (as in ordinary excitatory
% conditioning) or during the CS (as in our inhibitory experiments), the
% Dkl is undefined (or infinite) for the term that has the 0 rate, because
% log(0) is either undefined or -infinity and x/0 is infinite. This problem
% is easily (and very defensibly!) remedied by using Bayesian estimates of
% the rates. The Bayesian estimate of a rate adds an (often fractional!)
% prior pseudo-observation to the N on which the rate estimate is based. In
% other words, the rate estimate is Nobserved+alpha, where alpha typically has
% value 0.5 (for the Jeffrey's prior). Now all rate in the calculation of
% Hraw are positive and finite. When we do this, Hraw is dominated by
% whichever term has a non-zero OBSERVED (as opposed to estimated) rate,
% that is, by the CS rate in the excitatory case and by the ITI rate in the
% inhibitory case. Thus, IN THE EXCITATORY CASE, we have:
%      Hraw = (Ncs+.5)*[log(lamCS/lamRaw) + lamRaw/lamCS -1]   +
%             (Niti+.5)*[log(lamITI/lamRaw) + lamRaw/lamITI -1]
%  Ncs is a largish number (10-500) and lamCS/lamRaw is also large. To be
%  continued.
%
%     THE THIRD VERSION is the correct calculation of the cost of using the
% raw rate to generate a code for all the observed intervals. In the simple
% excitatory and inhibitory cases, all but 1 of the observed intervals
% occurs during the CS or the ITI, respectively, and then there is one
% steadily increasing interval for the other state, the null state. The
% rate estimates are modified by an alpha=.5 prior to prevent 0 estimates
%
%    THE FOURTH VERSION is Peter's suggestion that we consider the absolute
% value of the difference in the entropies, which is
% Ncs*|log(lamRaw)-log(lamCS)| + Niti*|log(lamRaw)-log(lamITI)|


CmCS=zeros(size(A,1),1);
Ton=0;
for r=2:length(CmCS)
    if A(r,2)>0 % CS onset
        Ton = -A(r,1);
        CmCS(r) = CmCS(r-1); % carry forward previous value
    elseif Ton && ~(A(r,2)<0) % during a CS
        CmCS(r) = CmCS(r-1)+A(r,1)+Ton; % increment by time elapsed since Ton
    elseif A(r,2) <0  % end of CS
        CmCS(r) = CmCS(r-1) + A(r,1)-A(r-1,1); % add increment
        Ton = 0; % zero Ton
    else % during ITI
        CmCS(r) = CmCS(r-1); % carry forward previous value
    end
end   
Aaug = [A CmCS]; % adds 4th column that gives cumulative CS duration
Aaug = [Aaug cumsum(A(:,3))]; % adds a 5th column that gives the US count
Aaug = [Aaug cumsum(A(:,2)<0)]; % adds a 6th column that gives the trial
%
% At any given row, Tb is in the 1st column of Aaug, Tcs is in 6th col),
% Nb is in the 5th col, Ncs = 0 (# of USs during CSs), and the trial count
% is in the 6th col. Therefore:
[~,UScntIncRows] = unique(Aaug(:,5)); % rows where US count increments
[~,TrlcntRows] = unique(Aaug(:,6)); % rows where CS count increments
strtr = find((Aaug(:,4)>0)&(Aaug(:,5)>0),1); % 1st row where lambdaC can be
% computed
UScntIncRows(UScntIncRows<strtr)=[]; % deleting early rows where lambdaC
%  cannot be computed
Aaug(:,7) = cumsum(cumsum(A(:,2))&A(:,3)); % count of USs during CSs
% cumsum(A(:,2)) is a logical vector flagging rows when CS present;A(:,2)
% flags USs; ANDing them gives an LV that flags USs during CSs; cumsumming
% that logical vector gives the count
Aaug(1,8:11)=0; % zeros in columns 8:11, the columns into which the
% two different cost calculations will be put
%%
for r = UScntIncRows'            
     % lambdaR = [Aaug(r,5)/Aaug(r,1) 0]; % raw rate vector
%      lambdaR = [Aaug(r,5)/Aaug(r,1) Aaug(r,7)/Aaug(r,4)]; % raw rate vector
     % Aaug(r,5) is US count; Aaug(r,1) is Tb; Aaug(r,7) is Ncs (# of USs
     % during CS); Aaug(r,4) is Tcs, time on the CS clock
     Tb = Aaug(r,1); % cumulative background time
     Tcs = Aaug(r,4); % cumulative CS time
     Nus = Aaug(r,5); % US count;
     Ncs = Aaug(r,7); % count of USs during CSs

     Aaug(r,8:11) = InfoGains_local(Tb,Tcs,Nus,Ncs,alpha);
     % In the current (June 8, 2017) version of the calculation of
     % information gain, three different algorithms are used. The first
     % (results of which appear in Col 8) approximates the Dkl simply by
     % the ratio of observed rate during ITIs to the observed raw rate; the
     % second approximates the Dkl by the log of this ratio; the third
     % gives the exact calculation: Niti*DklITI + Ncs*DklCS, where Niti is
     % the Bayesian estimate of the # of USs on the ITI clock, Ncs the
     % Bayesian estimate of the # of USs on the CS clock;
     % DklITI = log(lamITI/lamRaw) + lamRaw/lamITI - 1; % The divergence
        % OF the raw rate for the background FROM the observed rate. This is the
        % cost per interval of encoding the US-US intervals on the ITI clock using
        % the raw US rate instead of the corrected background rate
     % DklCS = log(lamCS/lamRaw) + lamRaw/lamCS - 1; % The divergence OF the
        % raw rate from the rate observed during the CS 
end
%
for i = strtr:length(Aaug) % filling in repeating values for 0's in Col 8&9
    if Aaug(i,8)==0
        Aaug(i,8)=Aaug(i-1,8);
    end
    if Aaug(i,9)==0
        Aaug(i,9)=Aaug(i-1,9);
    end
    if Aaug(i,10)==0
        Aaug(i,10)=Aaug(i-1,10);
    end
    if Aaug(i,11)==0
        Aaug(i,11)=Aaug(i-1,11);
    end
end
GperU = Aaug(UScntIncRows,[5,8:11]); % gain as of each US
GperT = Aaug(TrlcntRows,[6,8:11]); % gain as of each CS offset (trial conclusion)

function G = InfoGains_local(Tb,Tcs,Nb,Ncs,alpha)
% Code for computing the information gain from the protocol in three
% different ways: 1) Niti times the ratio OF the ITI US rate to the Raw US
% rate; 2) Niti times the natural log of this ratio; 3) the exact
% calculation, which is Nitib*DklITIb + Ncsb*DklCSb--see the calculation
% of the divergences in the last lines but one of this subfunction for
% documentation of the exact calculation

Nitio = Nb-Ncs; % observed # of USs on the clock that runs only during ITIs

lamITIo = Nitio/(Tb-Tcs); % observed rate during the ITI
lamRawo = Nb/Tb; % observed raw rate

Dkl1o = lamITIo/lamRawo;
Dkl2o = log(lamITIo/lamRawo);

Nitib = Nb-Ncs + alpha; % alpha comes from the prior; it prevents the rate
% estimate from ever being 0. Defensible values for alpha are .5 or 1. The
% b at the end of 'Nitib' is for Bayesian

Ncsb = Ncs + alpha; % ditto

Nbb = Nb + alpha; % ditto

lamITIb = Nitib/(Tb-Tcs); % "observed" rate during the ITI (modified by the prior)
lamCSb = Ncsb/Tcs; % "observed" rate during the CS (modified by the prior)
lamRawb = Nbb/Tb; % "observed" raw rate

DklITIb = log(lamITIb/lamRawb) + lamRawb/lamITIb - 1; % The divergence
% OF the raw rate for the background FROM the observed rate. This is the
% cost per interval of encoding the US-US intervals on the ITI clock using
% the raw US rate instead of the corrected background rate
DklCSb = log(lamCSb/lamRawb) + lamRawb/lamCSb - 1; % The divergence OF the
% raw rate from the rate observed during the CS

Ge = Nitib*DklITIb + Ncsb*DklCSb; % the correct calculation, that is, the
% cumulative cost in bits of encoding all the intervals, including the
% every-expanding single interval on the CS clock, using the raw rate model
% as opposed to the correct model, the model that predicts the actually
% observed CS and ITI rates

Gp = abs(Nitib*log(lamITIb) - Ncsb*log(lamCSb)); % Peter's suggestion that
% we use the absolute value of the difference in entropies rather than the
% Dkl

G = [Nitio*[Dkl1o Dkl2o] Ge Gp];